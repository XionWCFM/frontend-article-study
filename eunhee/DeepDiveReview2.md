
## 7장 연산자

### 1. 산술 연산자 : 수학적 계산을 수행해 새로운 숫자 값을 생성

- 이항 산술 연산자 : + , - 등

- 단항 산술 연산자 : ++ , -- , + ,-(양수<-> 음수 변환)

- 문자 연결 연산자 : + (피연산자중 하나 이상이 문자열인경우 문자열 연결 연산자로 동작)

* 단항 연산자를 사용할 때 숫자 타입이 아닌 피연산자를 연산하면 숫자 타입으로 변환해 반환한다.

```js
var x = '1';
console.log(+x); //숫자 1
console.log(x); //"1" 부수효과없음

var y = false;
console.log(+y); //숫자 0

var z = 'hello';
console.log(+z); //NaN
```

- 는 또한 피연산자중 하나 이상이 문자열인경우 문자열 연결 연산자로 동작한다.

```js
'1' + 2; //'12'
```

2. 할당 연산자 : 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
   = , += , -= 등

3. 비교 연산자

- 동등/일치 비교 연산자 ==, ===

- 대소 관계 비교 연산자 > , < ,>= , <=

NaN 은 일치 비교 연산자에서 자신과 일치 하지 않는 유일한 값임으로 주의하자.

일치 비교 연산자 사용시 숫자 0도 주의하자.

-> 대신 Object.is 메서드가 있다.

```js
//동등비교는 예측하기 어려워 안티 패턴이다.
'0' == ''; //false
0 == ''; //true

NaN === NaN; //false

null === null; //true

0 === -0; //true
0 == -0; //true

Object.is(-0, +0); //false;
Object.is(NaN, NaN); //true;
```

5. 논리 연산자 || , &&, !
   드 모르간의 법칙 을 애용하자

!(x || y) === (!x && !y)

!(x&& y)=== (!x || !y)

```js
//암묵적 타입 변환

!0; // true
!'hell'; //false

//단축평가
'cat' && 'dog'; //->dog
```

7. typeof 연산자
   주의사항으로 함수의 경우 "function" 을, null은 "object"로 반환하며 "null" 을 반환하는 경우는 없다.

선언한적 없는 식별자의 경우 undefined 를 반환한다

```js
typeof unddfdgff; // 에러가 아닌 undefined
```

등등 연산자는 많으나 생략한다.

## 08장 제어문

제어문 : 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행( 반복문)할때 사용.

- 블록문의 끝에는 세미콜론을 붙이지 않는다.

break 문 : 레이블문, 반복문, switch 문의 코드블록을 탈출함.

레이블문: 식별자가 붙은 문

레이블문은 중첩된 for문의 내부 for문에서 break 를 실행하면 내부 for 문 탈출이 아닌 외부 for문을 탈출할 시 유용하다.

```js
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    if (i + j === 3) break outer;
    console.log(`inner [${i}, ${j}]`);
  }
}
```

## 09장 타입 변환과 단축 평가

명시적 타입 변환, 타입 캐스팅 : 개발자가 의도적으로 값의 타입을 변환하는 것

암묵적 타입 변환, 타입 강제 변환: 개발자의 의도와 상관없이 표현식이 평가되는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것.

문자열 타입으로 변환 +연산자를 사용하고 피연산자중 하나 이상이 문자열일때

```js
0 + ''; //'0'
1 + ''; // '1'

true + ''; //'true'
```

문자열 타입으로 변환
산술 연산자를 사용할때,

+단항 연산자는 피연산자가 숫자 타입이 아니면 숫자 타입 의 값으로 암묵적 타입 변환을 수행

```js
1 -
  '1' + //0
  '' + //0
  '0' + //0
  false; //0
```

단축 평가
단축 평가: 표현식을 평가하는 도중 평가 결과가 확정나는 경우 나머지 평가과정은 생략하는 것.

- 논리곱 연산자&& 는 논리 연산의 결과를 결정하는 두 번째 피연산자가그대로 반환.

- 논리합 연산자||는 논리 연산의 결과를 결정하는 첫 번째 피연산자가 그대로 반환.

단축 평가 활용

1. 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할때

```js
var elem = null;

var value = elem && elem.value; //null
```

2. 함수 매개변수에 기본값을 설정할때

```js
function getString(str) {
  str = str || '';
  return str.length;
}

getString(); //0
getString('hi'); //2
```

단축 평가
단축 평가: 표현식을 평가하는 도중 평가 결과가 확정나는 경우 나머지 평가과정은 생략하는 것.

- 논리곱 연산자&& 는 논리 연산의 결과를 결정하는 두 번째 피연산자가그대로 반환.

- 논리합 연산자||는 논리 연산의 결과를 결정하는 첫 번째 피연산자가 그대로 반환.

단축 평가 활용

1. 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할때

->단 좌항 피연산자가 falsy 한 값이면 좌항 피연산자 그대로 반환

```js
var elem = null;

var value = elem && elem.value; //null
```

2. 함수 매개변수에 기본값을 설정할때

```js
function getString(str) {
  str = str || '';
  return str.length;
}

getString(); //0
getString('hi'); //2
```

옵셔널 체이닝 연산자 ?.
논리 연산자 &&는 좌항 피연산자 중 falsy 한 값으로 평가되면 좌항 피연산자 그대로 반환하는 경향이 있는 반면 옵셔널 체이닝 연산자 ?.는 좌항 연산자가 falsy 한 값이라도 null, undefined 가 아니면 우항의 프로퍼티 참조를 이어갑니다.

```js
var str = '';
var length = str && str.length;

console.log(length); //falsy 해서 무조건 str 그대로 '' 가 출력
var str = '';
var length = str?.length;

console.log(length); //0
```

null 병합 연산자 ??
같은 개념으로 논리 연산자 || 는 좌항 연산자 중 falsy 한 값으로 평가되면 우항 피연산자 그대로 반환하는 경향이 있는 반면 null 병합 연산자는 좌항 피연산자가 falsy 한 값이라도 null, undefined 가 아니면 좌항의 프로퍼티 참조를 이어갑니다.

```js
var foo = '' || 'default string';
console.log(foo); // default string

//null 과 undefined 일때만 기본값을 설정하고 싶다면
var foo = '' ?? 'default string';
console.log(foo); // ''
```

### 10장 객체 리터럴

자바스크립트의 객체는 함수와 밀접한 관계를 가진다. 함수로 객체를 생성하기도 하고 함수 자체가 객체이기도 하다.

인스턴스 : 클래스에 의해 생성되어 메모리에 저장된 실체.

객체지향 프로그래밍에서 객체= 클래스와 인스턴스를 포함한 개념.

프로퍼티 키: 빈 문자열을 포함하는 모든 문자열과 심벌값

식별자 네이밍을 안지켜도 되지만 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야한다.

프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 반환된다.

var 와 같은 예약어를 프로퍼티키로 사용해도 에러가 발생하지 않지만 예상치못한 에러가 발생할 여지 0

```js
var person = {
  firstName: 'Eun-Hee',
  'last-name': 'Lee', // 식별자네이밍을 준수하지 않는 프로퍼티 키 에는 따옴표가 필수
};
```

대활호 프로퍼티 접근 연산자 내부에 지정하는프로퍼티 키는 따옴표로 감싼 문자열이여야 하며 감싸지 않으면 식별자로 해석함.

객체에 존재하지 않는 프로퍼티를 접근하면 referenceError 가 아닌 undefined 반환,

```js
var person = {
  name: 'lee',
};

console.log(person[name]); //referenceError
console.log(person['name']); //lee
```

계산된 프로퍼티 이름

```js
var prefix = 'prop';
var i = 0;
var obj = {};

obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
```
